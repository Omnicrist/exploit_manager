import utils
import db_utils
import json


class Singleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = \
                super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]


class Settings(metaclass=Singleton):
    __DB = "db"
    __DB_NAME = "name"
    __DB_EXTENSION = "extension"
    __DB_PATH = "path"
    __SUBMIT = "submit"
    __SUBMIT_URL = "url"
    __SUBMIT_TOKEN = "token"
    __SUBMIT_REGEX = "regex"
    __SUBMIT_PROTOCOL = "protocol"
    __SUBMIT_MESSAGE_IF_VALID = "message_if_valid"
    __SUBMIT_MESSAGE_IF_INVALID = "message_if_invalid"

    def __init__(self, configuration_file: str):
        self.configuration_file = configuration_file
        self.configuration = self.read_configuration(self.configuration_file)
        utils.log_out(f"Successfully loaded {self.configuration_file}")
        self.__get_and_check_connection()
        self.__get_and_check_submit()

    def __get_db(self) -> str:
        try:
            db = self.configuration[Settings.__DB]
            return db[Settings.__DB_PATH] + db[Settings.__DB_NAME] \
                   + db[Settings.__DB_EXTENSION]
        except KeyError as e:
            utils.log_err(
                f"could not get db infos from {self.configuration_file}\n{e}")
            utils.exit_failure_settings()

    def __get_and_check_connection(self) -> None:
        db = self.__get_db()
        if db_utils.check_if_db_exists():
            connection = db_utils.connect(db)
            utils.log_out(f"{db} found!")
            if db_utils.check_if_flags_table_exists(connection):
                utils.log_out("flags table found!")
            else:
                utils.log_warn(f"flags table not found!")
                utils.log_warn(f"Creating flags table...")
                db_utils.create_table_flags(connection)
                utils.log_warn(f"Successfully created {db}!")
        else:
            utils.log_warn(f"{db} not found!")
            utils.log_warn(f"Creating {db}...")
            connection = db_utils.connect(db)
            db_utils.create_table_flags(connection)
            utils.log_warn(f"Successfully created {db}!")

        self.db = db
        connection.close()

    def __get_submit(self) -> (str, str, str, str, str, str):
        try:
            sbmt = self.configuration[Settings.__SUBMIT]
            url = sbmt[Settings.__SUBMIT_URL]
            tkn = sbmt[Settings.__SUBMIT_TOKEN]
            rgx = sbmt[Settings.__SUBMIT_REGEX]
            prtcl = sbmt[Settings.__SUBMIT_PROTOCOL]
            msg_if_vld = sbmt[Settings.__SUBMIT_MESSAGE_IF_VALID]
            msg_if_invld = sbmt[Settings.__SUBMIT_MESSAGE_IF_INVALID]
            return url, tkn, rgx, prtcl, msg_if_vld, msg_if_invld
        except KeyError as e:
            utils.log_err(
                "could not get submit infos from "
                f"{self.configuration_file}\n{e}")
            utils.exit_failure_settings()

    def __get_and_check_submit(self) -> None:
        url, tkn, rgx, prtcl, msg_if_vld, msg_if_invld = self.__get_submit()

        # TODO check if the url is reachable and if submitting an
        #  invalid flag produces message_if_invalid as output

        # So, after checking, we can assign variables to the class
        self.submit_url = url
        self.submit_token = tkn
        self.submit_regex = rgx
        self.submit_protocol = prtcl.upper()
        self.submit_message_if_valid = msg_if_vld
        self.submit_message_if_invalid = msg_if_invld

    def read_configuration(self, filename=r"./conf.json") -> dict:
        try:
            with open(filename, 'r') as f:
                try:
                    return json.loads(f.read())
                except json.JSONDecodeError as error:
                    utils.log_err(
                        f"Reading {filename} generated:\n{str(error)}")
                    utils.exit_failure_settings()
        except FileNotFoundError as error:
            utils.log_err(f"Opening  {filename} generated:\n{str(error)}")
            utils.exit_failure_settings()
