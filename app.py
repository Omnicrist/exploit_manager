#!/usr/bin/env python3
import flask
import json
import db_utils
import utils
import manager
import os
import endpoints
from functools import wraps
from datetime import timedelta
from queued_submit import QueuedSubmitter

app = flask.Flask(__name__)
app.config['SECRET_KEY'] = 'no_personal_data_involved_with_this_key'
session_duration = 7200
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(seconds=session_duration)
app.thread_struct = {}
global settings
global queued_submitter


def catchError(func):
    @wraps(func)
    def exceptionLogger(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            utils.log_err("Exception in {}: {} {}".format(func.__name__, e.__class__.__name__, str(e)))
            return flask.redirect('/')

    return exceptionLogger


@app.route('/favicon.ico', methods=["GET"])
@catchError
def favicon():
    return flask.send_from_directory(os.path.join(app.root_path, 'static', 'images'), 'uninap.png', mimetype='image/png')


@app.route('/', methods=['GET'])
def index():
    """HOME DELL'INTERFACCIA"""

    return flask.render_template('/public_html/index.html')


@app.route('/exploits', methods=['GET'])
@catchError
def exploits():
    """PAGINA PER LA GESTIONE DEGLI EXPLOITS
    DA QUI SI PUO' EFFETTUARE L'UPLOAD"""
    
    return flask.render_template('/public_html/upload.html')


@app.route('/api/getExploits', methods=['GET'])
@catchError
def getExploits():
    """RITORNA GLI EXPLOITS E I RELATIVI DATI"""

    # Reading exploits stats from db
    global settings
    db = db_utils.connect(settings.db)
    data = db_utils.get_count_attacks(db)
    db.close()

    # Summing the flags obtained by an exploit for each opponent
    totals = dict([(row[1], row[0]) for row in data])
    services = [row[1] for row in data]
    status = [1 if service in app.thread_struct else 0 for service in services]

    response = app.response_class(
        response = json.dumps({"services": services, "totals": totals, "status": status}),
        status = 200,
        mimetype='application/json'
    )
    return response


@app.route('/api/uploadExploit', methods=['POST'])
@catchError
def uploadExploit():
    """UPLOAD DEGLI EXPLOIT"""
    global settings
    global queued_submitter
    
    try:
        f = flask.request.files['myFile']
    except ValueError:
        utils.log_err("POST REQUEST SENZA FILE\n")
        return flask.redirect('/exploits')

    if f.filename == '':
        utils.log_err("EXPLOIT UPLOAD VUOTO\n")
        return flask.redirect('/exploits')

    json_str = json.loads(f.read().decode("utf-8"))
    
    manager.run_exploits(json_str, settings, globals(), app.thread_struct, queued_submitter)

    return flask.redirect('/exploits')


@app.route('/api/getTargets', methods=['GET'])
@catchError
def getTargets():
    """RETURN TARGETS DATA"""
    global settings
    if "service" in flask.request.args.keys():
        service = flask.request.args['service']
        if "targets" in flask.request.args.keys():
            # request of targets data for a given service
            targets = flask.request.args.getlist('targets')
        else:
            # request of all targets data for a given service
            targets = None
        db_name = settings.db
        data = endpoints.api_exploit_get_targets_stats(service, targets, app.thread_struct, db_name)
        # data = {"targets": [{"name": "Paolo", "flag": 69, "active": 1}, {"name": "Marco", "flag": 420, "active": 0}]}
    else:
        data = {"error": "Invalid parameters"}

    response = app.response_class(
        response = json.dumps(data),
        status = 200,
        mimetype='application/json'
    )
    return response


@app.route('/api/swapState', methods=['GET'])
@catchError
def swapState():
    """SWAP THE STATE OF ONE OR MORE TARGETS FOR A GIVEN SERVICE"""
    
    if "service" in flask.request.args.keys():
        service = flask.request.args['service']
        if "targets" in flask.request.args.keys():
            targets = flask.request.args.getlist("targets")
        else:
            targets = None
        print("Swapping service: {}".format(service))   # DEBUG
        print("Swapping targets: {}".format(targets))   # DEBUG
        data = endpoints.api_exploit_switch_state(service, targets, app.thread_struct)
    else:
        data = {"error": "Invalid parameters"}

    response = app.response_class(
        response = json.dumps(data),
        status = 200,
        mimetype='application/json'
    )
    return response


@app.route('/editor', methods=['GET', 'POST'])
@catchError
def editor():
    if flask.request.method == 'GET':
        if 'code' in flask.session:
            exploit_text = flask.session['code']
        else:
            uuid = os.urandom(16).hex()
            with open('custom/exploit.py', 'r') as f:
                exploit_text = f.read().replace('uuid_exploit.JSON', '{}.JSON'.format(uuid))
            flask.session.permanent = True
            flask.session['code'] = exploit_text
            flask.session['uuid'] = uuid
        return flask.render_template('public_html/editor.html', code=exploit_text)
    elif flask.request.method == 'POST':
        if 'code' in flask.session:
            if flask.request.form.get('code'):
                flask.session['code'] = flask.request.form.get('code')
                return "Code saved successfully into session, will expire after {} seconds of inactivity".format(session_duration)
            elif flask.request.form.get('run'):
                uuid, code = flask.session['uuid'], flask.session['code']
                with open("volume/{}.py".format(uuid), 'w') as f:
                    f.write(code)
                if "util_marshal.py" not in os.listdir("volume"):
                    os.system("cp util_marshal.py volume")
                    # need it to serialize function specified in volume/uuid.py
                os.system("python -u volume/{}.py > volume/{} 2>&1".format(uuid, uuid))
                with open("volume/{}".format(uuid), 'r') as f:
                    result = f.read()
                with open("volume/{}.JSON".format(uuid), 'r') as f:
                    serialized_exploit = f.read()
                os.system("rm -f volume/{}*".format(uuid))
                flask.session['serialized_exploit'] = serialized_exploit
                return "You can now download the serialized exploit; run output: {}".format(result)
            elif flask.request.form.get('reload'):
                _keys = [_key for _key in flask.session.keys()]
                [flask.session.pop(key) for key in _keys]
                return "Ok"
            elif flask.request.form.get('download'):
                if 'serialized_exploit' in flask.session:
                    return flask.Response(flask.session['serialized_exploit'], mimetype='application/json')
                else:
                    error_msg = "Download not available; maybe you want to RUN the script first"
                    return flask.Response(json.dumps({"Error": error_msg}), mimetype='application/json')
            elif flask.request.form.get('yield'):
                _keys = [_key for _key in flask.session.keys()]
                [flask.session.pop(key) for key in _keys]
                uuid = os.urandom(16).hex()
                with open('custom/exploit_yield.py', 'r') as f:
                    exploit_text = f.read().replace('uuid_exploit.JSON', '{}.JSON'.format(uuid))
                flask.session.permanent = True
                flask.session['code'] = exploit_text
                flask.session['uuid'] = uuid
                return flask.render_template('public_html/editor.html', code=exploit_text)
            else:
                return "Missing operands"
        else:
            return flask.redirect('/editor')
    else:
        return "Unsupported method"


@app.route('/conf.json', methods=['GET'])
@catchError
def show_conf():
    with open('volume/conf.json', 'r') as f:
        conf = f.read()
    return conf


def init():
    global settings
    global queued_submitter
    if "util_marshal.py" not in os.listdir("volume"):
        os.system("cp util_marshal.py volume")
    # should write the custom serialized script in path/filename as specified in conf.json
    # default: submit.json in app folder
    os.system("python volume/custom_submitter.py")
    settings = manager.load_setup(globals())
    if settings.submit_protocol == 'CUSTOM-QUEUED':
        queued_submitter = QueuedSubmitter(settings, globals())
        queued_submitter.start()
    else:
        queued_submitter = None


if __name__ == '__main__':
    init()
    app.run(host="0.0.0.0", port="5000", debug=True)
