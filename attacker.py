import threading
import db_utils
import settings
import requests
from pwn import *
from submitter import CustomSubmitter


class Attacker(threading.Thread):
    def __init__(self, stngs: settings.Settings,
                 opponent: str, service: str, exploit):  # TODO Type hint? -> builtins.function, need to install
        super().__init__()
        self.settings = stngs
        self.opponent = opponent
        self.service = service
        self.exploit = exploit
        self.stop = False
        self.killed = False
        self.errors = 0
        self.last_flag_time = time.time()
        self.elapsed_flag_time = self.last_flag_time

    def get_valid_flags(self, flags: set) -> set:
        new_flags = set()
        for flag in flags:
            connection = db_utils.connect(self.settings.db)
            if not db_utils.check_if_a_flag_is_present_in_db(connection, flag):
                new_flags.add(flag)
            connection.close()
        return new_flags

    def submit_flags(self, flags: set, submitter: CustomSubmitter):
        for flag in flags:
            connection = db_utils.connect(self.settings.db)
            self.__submit_flag(flag, submitter)
            db_utils.insert_flag_in_db(connection, flag,
                                       self.opponent, self.service)
            connection.close()

    def __submit_flag(self, flag: str, submitter: CustomSubmitter):
        data = {'team_token': self.settings.submit_token, 'flag': flag}
        try:
            if self.settings.submit_protocol == "POST":
                r = requests.post(self.settings.submit_url, data=data)
            elif self.settings.submit_protocol == "GET":
                r = requests.get(self.settings.submit_url, data=data)
            elif self.settings.submit_protocol == "TCP":
                url, port = self.settings.submit_url.split(":")
                conn = remote(url, port)
                conn.sendline(flag)
                conn.close()
            elif self.settings.submit_protocol == "CUSTOM":
                # the one in comment raises error
                # submitter.submit(flag, self.settings.submit_url, self.settings.submit_token)
                submitter.submitter['submitter'](flag, self.settings.submit_url, self.settings.submit_token)
        except requests.RequestException:
            print(f"[+] An exception occurred while submitting a flag")
        except PwnlibException as e:
            print(f"[+] An exception occurred while submitting a flag:\n{e}")
        else:
            print(f"[+] Flag {flag} submitted")

    def kill(self):
        self.killed = True

    def switch_state(self):
        self.stop = not self.stop

    def is_active(self):
        return 1 if not self.stop else 0

    def run(self):
        # auto-stop if it has error_threshold consecutive errors
        error_threshold = self.settings.thread_error_th
        submitter = CustomSubmitter(self.settings, globals())   # it is a singleton
        while True:
            # auto-stop if it isn't finding new flags after some time
            low_performance = (self.elapsed_flag_time - self.last_flag_time) >= (2 * self.settings.tick)
            if (self.errors >= error_threshold) or low_performance:
                self.stop = True
            if self.killed:
                self.stop = True
                break
            if not self.stop:
                print(f"[+] Now attacking target: {self.opponent}")
                try:
                    flags = set(self.exploit(self.opponent))
                    new_flags = self.get_valid_flags(flags)
                    if len(new_flags) > 0:
                        self.last_flag_time = time.time()
                        self.elapsed_flag_time = self.last_flag_time
                    else:
                        # elapsed time tends to be equal to last flag time if new flags are always found
                        self.elapsed_flag_time = time.time()
                    self.submit_flags(new_flags, submitter)
                    if self.errors > 0:
                        self.errors -= 1
                except:
                    self.errors += 1
            else:
                time.sleep(1)   # reduce CPU usage from stopped threads
